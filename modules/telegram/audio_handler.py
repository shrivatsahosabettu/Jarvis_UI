import importlib
import logging
import os
import time
from logging.config import dictConfig
from typing import Callable, NoReturn, Union

import pyttsx3
from speech_recognition import AudioFile, Recognizer, UnknownValueError

from modules.models import config, models
from modules.timeout import timeout
from modules.utils import shared

indicators = models.Indicators()
recognizer = Recognizer()

env = models.env
audio_driver = pyttsx3.init()
importlib.reload(module=logging) if env.macos else None
dictConfig(config.BotConfig().dict())
logger = logging.getLogger('telegram')

voices = audio_driver.getProperty("voices")  # gets the list of voices available
voice_model = "Daniel" if env.macos else "David"
for ind_d, voice_id in enumerate(voices):  # noqa
    if voice_id.name == voice_model or voice_model in voice_id.name:
        audio_driver.setProperty("voice", voices[ind_d].id)  # noqa


def audio_converter_mac() -> Callable:
    """Imports transcode from ftransc.

    Returns:
        Callable:
        Transcode function from ftransc.
    """
    try:
        from ftransc.core.transcoders import transcode  # noqa
        return transcode
    except SystemExit as error:
        logger.error(error)


def audio_converter_win(input_filename: str, output_audio_format: str) -> Union[str, None]:
    """Imports AudioSegment from pydub.

    Args:
        input_filename: Input filename.
        output_audio_format: Output audio format.

    Returns:
        str:
        Output filename if conversion is successful.
    """
    ffmpeg_path = os.path.join(os.getcwd(), "ffmpeg", "bin")
    if not os.path.exists(path=ffmpeg_path):
        logger.warning("ffmpeg codec is missing!")
        return
    os.environ['PATH'] += ffmpeg_path
    from pydub import AudioSegment  # noqa
    if input_filename.endswith(".ogg"):
        audio = AudioSegment.from_ogg(input_filename)
        output_filename = input_filename.replace(".ogg", f".{output_audio_format}")
    elif input_filename.endswith(".wav"):
        audio = AudioSegment.from_wav(input_filename)
        output_filename = input_filename.replace(".wav", f".{output_audio_format}")
    else:
        return
    try:
        audio.export(input_filename, format=output_audio_format)
        os.remove(input_filename)
        if os.path.isfile(output_filename):
            return output_filename
        raise FileNotFoundError(
            f"{output_filename} was not found after exporting audio to {output_audio_format}"
        )
    except FileNotFoundError as error:  # raised by audio.export when conversion fails
        logger.error(error)


def generate_audio_file(filename: str, text: str) -> NoReturn:
    """Generates an audio file from text.

    Args:
        filename: Filename to be generated.
        text: Text that has to be converted into audio.
    """
    logger.info(f"Generating audio into {filename} from the text: {text}")
    audio_driver.save_to_file(filename=filename, text=text)
    audio_driver.runAndWait()


def audio_to_text(filename: str) -> str:
    """Converts audio to text using speech recognition.

    Args:
        filename: Filename to process the information from.

    Returns:
        str:
        Returns the string converted from the audio file.
    """
    try:
        file = AudioFile(filename_or_fileobject=filename)
        with file as source:
            audio = recognizer.record(source)
        os.remove(filename)
        return recognizer.recognize_google(audio)
    except UnknownValueError:
        logger.error("Unrecognized audio or language.")


def text_to_audio(text: str) -> Union[str, None]:
    """Converts text into an audio file.

    Args:
        text: Takes the text that has to be converted as audio.

    Returns:
        str:
        Returns the temporary filename.
    """
    if shared.offline_caller:
        tmp_file = f"{shared.offline_caller}.wav"
        shared.offline_caller = None  # Reset caller after using it
    else:
        tmp_file = f"{int(time.time())}.wav"
    response = timeout.timeout(function=generate_audio_file, seconds=env.bot_voice_timeout, logger=logger,
                               kwargs={'filename': tmp_file, 'text': text})
    if not response.ok:
        logger.warning(response.info)
    if os.path.isfile(tmp_file):
        logger.info(f"Generated {tmp_file}")
        if env.macos:
            # Since Telegram is unable to process wav files generated by macOS
            if (transcode := audio_converter_mac()) and transcode(input_file_name=tmp_file,
                                                                  output_audio_format="mp3"):
                os.remove(tmp_file)
                tmp_file = tmp_file.replace(".wav", ".mp3")
        return tmp_file
    logger.error("Failed to generate audio from text within the set timeout.")
